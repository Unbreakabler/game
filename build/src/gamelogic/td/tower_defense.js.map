{"version":3,"file":"tower_defense.js","sources":["../../../../../src/gamelogic/td/tower_defense.ts"],"sourcesContent":["import { Exclude } from \"class-transformer\";\n\nconst BASIC_TOWER_DEFAULT_ID = 'basic_1'\nconst MACHINE_GUN_TOWER_DEFAULT_ID = 'machine_gun_1'\n\ntype TowerId = string\nexport interface TowerInfo {\n  tier: integer;\n  type: TowerType;\n  range: integer;\n  damage: number;\n  attack_speed: number;\n  projectiles: number;\n  spread_angle: number;\n  area_of_effect_radius: number;\n  x: number;\n  y: number;\n  is_placed: boolean;\n  is_selected: boolean;\n\n  damage_dealt_lifetime: number;\n  damage_dealt_this_prestige: number;\n}\n\nconst BasicTowerInfoDefaults: TowerInfo = {\n  tier: 0,\n  type: 'basic',\n  range: 200,\n  damage: 50,\n  attack_speed: 1000,\n  projectiles: 1,\n  spread_angle: 0,\n  area_of_effect_radius: 0,\n  x: 0,\n  y: 0,\n  is_placed: false,\n  is_selected: false,\n  damage_dealt_lifetime: 0,\n  damage_dealt_this_prestige: 0,\n}\n\nconst MachineGunTowerInfoDefaults: TowerInfo = {\n  tier: 0,\n  type: 'machine_gun',\n  range: 100,\n  damage: 2,\n  attack_speed: 100,\n  projectiles: 1,\n  spread_angle: 0,\n  area_of_effect_radius: 0,\n  x: 0,\n  y: 0,\n  is_placed: false,\n  is_selected: false,\n  damage_dealt_lifetime: 0,\n  damage_dealt_this_prestige: 0,\n}\n\ninterface Stats {\n  [tower_id: string] : TowerStats\n}\n\ninterface TowerStats { \n  kills: { lifetime: number, prestige: number, [enemy_name: string]: number },\n  damage: {\n    lifetime: number,\n    prestige: number,\n    types?: {\n      fire?: number,\n      ice?: number,\n      //etc\n    }\n  }\n}\n\n\n// TODO(jon): Need to generate default stats objects when a the slot tower_id's change?\n// Actually, we need to gen these stat objects when a tower is placed for the first time.\n// If a tower is removed, we need to keep the stats. If a tower is merged with another tower\n// should we combine the stats? Should we record a history of merges?\nconst defaultStats: Stats = {\n  [BASIC_TOWER_DEFAULT_ID]: {\n    kills: {\n      lifetime: 0,\n      prestige: 0,\n      green_knight: 0,\n    },\n    damage: {\n      lifetime: 0,\n      prestige: 0,\n    }\n  },\n  [MACHINE_GUN_TOWER_DEFAULT_ID]: {\n    kills: {\n      lifetime: 0,\n      prestige: 0,\n      green_knight: 0,\n    },\n    damage: {\n      lifetime: 0,\n      prestige: 0,\n    }\n  }\n}\n\nexport type TowerType = 'basic' | 'machine_gun'\n\nexport type SelectionCursor = 'placement' | 'selected'\n\nexport class TowerDefense {\n  @Exclude() public selection: { type: TowerType, id: TowerId, cursor: SelectionCursor } | null = null;\n\n  // Need to expose below but it breaks\n  public towers: { [K in TowerType]: TowerId[][]};\n  private tower_map: { [tower_id: string]: TowerInfo };\n  public slots: Array<string | null>\n  public stats: Stats = {}\n\n  public constructor() {\n    this.towers = get_default_towers();\n    this.tower_map = get_default_tower_map();\n    this.slots = [BASIC_TOWER_DEFAULT_ID, MACHINE_GUN_TOWER_DEFAULT_ID, null, null, null]\n    this.slots.forEach(tower_id => {\n      if (tower_id) {\n        this.stats[tower_id] = generate_default_stats()\n      }\n    })\n  }\n\n  public getTower(id: TowerId): TowerInfo | undefined {\n    return this.tower_map[id]\n  }\n\n  public getTowerStats(id: TowerId): TowerStats {\n    const tower_stats = this.stats[id]\n    if (tower_stats) return this.stats[id]\n    this.stats[id] = generate_default_stats()\n    return this.stats[id]\n  }\n\n  public setSelection(id: TowerId | null, cursor: SelectionCursor = 'selected') {\n    if (!id) {\n      this.selection = null; \n      return;\n    }\n    if (id in this.tower_map) {\n      const type = this.tower_map[id].type\n      this.selection = { type, id, cursor }\n    }\n  }\n\n  public selectHighestTierForPlacement(tower_type: TowerType) {\n    // Should I check if there is a \"selectable\" tower of this type available first?\n    const tower_list = this.towers[tower_type]\n    if (!tower_list) return\n    \n    // iterate backwards through list until we find an unplaced tower of this type\n    const highest_tier_available_tower_list = tower_list.slice().reverse().flat();\n\n    const highest_tier_available_tower_id = highest_tier_available_tower_list.find(tower_id => {\n      const tower = this.getTower(tower_id)\n      if (!tower) return\n      return !tower.is_placed\n    })\n    if (!highest_tier_available_tower_id) return\n\n    this.setSelection(highest_tier_available_tower_id)\n  }\n\n  public placeTower(id: TowerId, x: number, y: number) {\n    const tower = this.tower_map[id]\n    if (!tower) return\n\n    tower.x = x;\n    tower.y = y;\n    tower.is_placed = true;\n    tower.is_selected = false;\n  }\n\n  public recordTowerDamage(tower_id: string, damage: number) {\n    const tower = this.getTower(tower_id)\n    if (!tower) return\n\n    const tower_stats = this.getTowerStats(tower_id)\n    tower_stats.damage.prestige += damage;\n\n    // TODO(jon): track tower accuracy, projectiles fired, etc etc\n  }\n\n  public recordTowerKill(tower_id: string, enemy_name: string) {\n    const tower = this.getTower(tower_id)\n    if (!tower) return\n\n    const tower_stats = this.getTowerStats(tower_id)\n    if (!tower_stats.kills) tower_stats.kills = { lifetime: 0, prestige: 0 }\n    if (!tower_stats.kills[enemy_name]) tower_stats.kills[enemy_name] = 0;\n    tower_stats.kills.prestige++;\n    tower_stats.kills[enemy_name]++;\n  }\n}\n\n// By default you have a single \"basic\" tower and a single \"machine_gun\" tower.\nconst get_default_towers = () => {\n  return {\n    'basic': [[BASIC_TOWER_DEFAULT_ID]],\n    'machine_gun': [[MACHINE_GUN_TOWER_DEFAULT_ID]]\n  }\n}\n\nconst get_default_tower_map = () => {\n  return {\n    [BASIC_TOWER_DEFAULT_ID]: BasicTowerInfoDefaults,\n    [MACHINE_GUN_TOWER_DEFAULT_ID]: MachineGunTowerInfoDefaults\n  }\n}\n\nconst generate_default_stats = () => {\n  return {\n    kills: {\n      lifetime: 0,\n      prestige: 0,\n    },\n    damage: {\n      lifetime: 0,\n      prestige: 0,\n    }\n  }\n}\n\n// Tower data structure.\n// Requirements:\n// 1. Track multiple towers of multiple \"tiers\".\n// 2. Merge multiple towers of the same tier into higher tiers.\n// 3. Track counts of towers owned at each tier.\n// 4. Automatically upgrade towers to the highest, or specific, tier (upgrade).\n\n// IDEAS:\n/*\nArray of arrays; The index of the out array corresponds to tower tier,\nie: towers[0] = list of all owned tier 1 tower ids, towers[1] = tier 2, etc.\n\nMerging can be accomplished by iterating through the list a single time,\nif any of the nested lists have len >= 2 they can be upgraded to the nex tier.\n\nWhen a new tower is added, a new ID is generated. When two towers are merged\na new tower is generated with a new ID, the old towers/ids are deleted.\nThe new tower will be roughly 2.1x as strong as the previous version making\nit always worthwhile to upgrade.\n\ntowers = [\n  [id1, id2, id4, id5],\n  []\n  [id3]\n]\n\nThis only works for a single tower type, to manage multiple tower types\nwe either need to store more information in the inner lists (and then check this on iteration).\nOr we need to store each tower type as its own array of arrays.\n\n2.0 idea:\n\ntowers = {\n  'basic': [\n    [id1, id2],\n  ],\n  'machine_gun': [\n    [id3, id4],\n    [id5]\n  ]\n}\n\n// Hashmap to lookup all towers in O(1) time, this allows us to easily pull up tower\n// stats when selecting a tower\ntower_map = {\n  id1: {\n    type: 'basic', \n    tier: 0,\n  },\n  id3: {\n    type: 'machine_gun',\n    tier: 0,\n  },\n  id5: {\n    type: 'machine_gun',\n    tier: 1, \n  }\n}\n\ntower_slots = [\n  {\n    modifiers: [burning_effect, freezing_effect]\n  }\n]\n\nmodifier_map = {\n  burning_effect: {\n    // Applies a visual burning effect\n    // deals X% of damage over X seconds\n  },\n  freezing_effect: {\n    // applies a cold effect\n    // causes enemies effected to move X% slower for X seconds\n  },\n}\n\nEach tower type is stored as an array of arrays.\nTowers are infinitely upgradeable, the upgrade stats will follow a forumla.\n\nQuestions:\n\nHow would you place multiple basic towers? How would you tell if you\nwere placing a tier 1 or a tier 2? \nDo we need a visual indicator on the hover placement? (I think yes)\n\nIf you have the 'basic' tower in 'slot_1', and you place two of them,\nthe first tower will be the highest level, the next tower placed will be\nthe next highest level available (which could be a jump from tier 10000 to tier 1.)\n\nTower formula:\n\nbasic:\n\nrange = 200\ndamage = 50 + tier*55\nprojectiles = 1 + Math.floor(tier/100) // additional proj every 100 tiers\nattack_speed = Math.max(1000 - tier, 250) // first once a second, increase attack speed for first 750 levels.\n\n\nmachine_gun:\n\nrange: 50,\ndamage: 2 + level*3,\nprojectiles: 100,\nspread_arc: PI/12 // 15 degree spread arc\n\n\nTODO:\n1. Store tower state in svelte store and serialize/deserialize tower position.\n  - Place towers in the correct position when refreshing the game.\n2. Track the amount of enemies that have been leaked through the TD.\n3. Use a factory to generate new turrets and add them to turret lists/map\n\n*/"],"names":[],"mappings":"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"}