import { SvelteComponent, init, safe_not_equal, element, text, space, attr, insert, append, listen, set_data, detach, run_all, empty, noop } from '../../node_modules/svelte/internal/index.mjs.js';
import { gameModel } from '../gamelogic/gamemodel.js';

/* src/components/tower_details.svelte generated by Svelte v3.32.1 */

function create_if_block(ctx) {
	let div10;
	let div0;
	let span;
	let t0;
	let t1_value = /*tower_info*/ ctx[0].status.targeting_mode + "";
	let t1;
	let t2;
	let button0;
	let t4;
	let button1;
	let t6;
	let div1;
	let t7;
	let t8_value = /*tower_stats*/ ctx[1].kills.lifetime + /*tower_stats*/ ctx[1].kills.prestige + "";
	let t8;
	let t9;
	let div2;
	let t10;
	let t11_value = /*tower_stats*/ ctx[1].kills.prestige + "";
	let t11;
	let t12;
	let div3;
	let t13;
	let t14_value = /*tower_stats*/ ctx[1].damage.lifetime + /*tower_stats*/ ctx[1].damage.prestige + "";
	let t14;
	let t15;
	let div4;
	let t16;
	let t17_value = /*tower_stats*/ ctx[1].damage.prestige + "";
	let t17;
	let t18;
	let div5;
	let t19_value = /*tower_info*/ ctx[0].status.type + "";
	let t19;
	let t20;
	let div6;
	let t21;
	let t22;
	let t23;
	let div7;
	let t24;
	let t25_value = /*tower_info*/ ctx[0].attributes.damage + "";
	let t25;
	let t26;
	let div8;
	let t27;
	let t28_value = /*tower_info*/ ctx[0].attributes.attack_speed / 1000 + "";
	let t28;
	let t29;
	let t30;
	let div9;
	let t31;
	let t32_value = JSON.stringify(/*tower_info*/ ctx[0].attributes.projectile_modifiers, null, 2) + "";
	let t32;
	let mounted;
	let dispose;

	return {
		c() {
			div10 = element("div");
			div0 = element("div");
			span = element("span");
			t0 = text("targeting: ");
			t1 = text(t1_value);
			t2 = space();
			button0 = element("button");
			button0.textContent = "Next";
			t4 = space();
			button1 = element("button");
			button1.textContent = "Prev";
			t6 = space();
			div1 = element("div");
			t7 = text("lifetime kills: ");
			t8 = text(t8_value);
			t9 = space();
			div2 = element("div");
			t10 = text("prestige kills: ");
			t11 = text(t11_value);
			t12 = space();
			div3 = element("div");
			t13 = text("lifetime damage: ");
			t14 = text(t14_value);
			t15 = space();
			div4 = element("div");
			t16 = text("prestige damage: ");
			t17 = text(t17_value);
			t18 = space();
			div5 = element("div");
			t19 = text(t19_value);
			t20 = space();
			div6 = element("div");
			t21 = text("dps: ");
			t22 = text(/*dps*/ ctx[2]);
			t23 = space();
			div7 = element("div");
			t24 = text("damage per hit: ");
			t25 = text(t25_value);
			t26 = space();
			div8 = element("div");
			t27 = text("attack time: ");
			t28 = text(t28_value);
			t29 = text("s");
			t30 = space();
			div9 = element("div");
			t31 = text("proj mods: ");
			t32 = text(t32_value);
			attr(div10, "class", "details svelte-8xie7");
		},
		m(target, anchor) {
			insert(target, div10, anchor);
			append(div10, div0);
			append(div0, span);
			append(span, t0);
			append(span, t1);
			append(div0, t2);
			append(div0, button0);
			append(div0, t4);
			append(div0, button1);
			append(div10, t6);
			append(div10, div1);
			append(div1, t7);
			append(div1, t8);
			append(div10, t9);
			append(div10, div2);
			append(div2, t10);
			append(div2, t11);
			append(div10, t12);
			append(div10, div3);
			append(div3, t13);
			append(div3, t14);
			append(div10, t15);
			append(div10, div4);
			append(div4, t16);
			append(div4, t17);
			append(div10, t18);
			append(div10, div5);
			append(div5, t19);
			append(div10, t20);
			append(div10, div6);
			append(div6, t21);
			append(div6, t22);
			append(div10, t23);
			append(div10, div7);
			append(div7, t24);
			append(div7, t25);
			append(div10, t26);
			append(div10, div8);
			append(div8, t27);
			append(div8, t28);
			append(div8, t29);
			append(div10, t30);
			append(div10, div9);
			append(div9, t31);
			append(div9, t32);

			if (!mounted) {
				dispose = [
					listen(button0, "click", /*click_handler*/ ctx[6]),
					listen(button1, "click", /*click_handler_1*/ ctx[7])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*tower_info*/ 1 && t1_value !== (t1_value = /*tower_info*/ ctx[0].status.targeting_mode + "")) set_data(t1, t1_value);
			if (dirty & /*tower_stats*/ 2 && t8_value !== (t8_value = /*tower_stats*/ ctx[1].kills.lifetime + /*tower_stats*/ ctx[1].kills.prestige + "")) set_data(t8, t8_value);
			if (dirty & /*tower_stats*/ 2 && t11_value !== (t11_value = /*tower_stats*/ ctx[1].kills.prestige + "")) set_data(t11, t11_value);
			if (dirty & /*tower_stats*/ 2 && t14_value !== (t14_value = /*tower_stats*/ ctx[1].damage.lifetime + /*tower_stats*/ ctx[1].damage.prestige + "")) set_data(t14, t14_value);
			if (dirty & /*tower_stats*/ 2 && t17_value !== (t17_value = /*tower_stats*/ ctx[1].damage.prestige + "")) set_data(t17, t17_value);
			if (dirty & /*tower_info*/ 1 && t19_value !== (t19_value = /*tower_info*/ ctx[0].status.type + "")) set_data(t19, t19_value);
			if (dirty & /*dps*/ 4) set_data(t22, /*dps*/ ctx[2]);
			if (dirty & /*tower_info*/ 1 && t25_value !== (t25_value = /*tower_info*/ ctx[0].attributes.damage + "")) set_data(t25, t25_value);
			if (dirty & /*tower_info*/ 1 && t28_value !== (t28_value = /*tower_info*/ ctx[0].attributes.attack_speed / 1000 + "")) set_data(t28, t28_value);
			if (dirty & /*tower_info*/ 1 && t32_value !== (t32_value = JSON.stringify(/*tower_info*/ ctx[0].attributes.projectile_modifiers, null, 2) + "")) set_data(t32, t32_value);
		},
		d(detaching) {
			if (detaching) detach(div10);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment(ctx) {
	let if_block_anchor;
	let if_block = /*tower_info*/ ctx[0] && create_if_block(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, [dirty]) {
			if (/*tower_info*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let selection;
	
	let gameModelInstance;
	gameModel.subscribe(m => $$invalidate(4, gameModelInstance = m));
	let tower_info = undefined;
	let tower_stats = undefined;
	let dps = 0;

	// TODO(jon): Once there are tower types with unique targeting modes this should be pulled from tower info
	const targeting_modes = ["first", "last", "strongest", "closest"];

	const changeTargetingMode = x => {
		// find index of targeting_mode
		// select next/prev item in list, or roll back to start (modulo)
		const cur_index = targeting_modes.findIndex(v => v === tower_info?.status.targeting_mode);

		const new_index = (cur_index + x) % targeting_modes.length;
		const new_targeting_mode = targeting_modes[new_index];
		if (tower_info) $$invalidate(0, tower_info.status.targeting_mode = new_targeting_mode, tower_info);
	};

	const click_handler = () => changeTargetingMode(1);
	const click_handler_1 = () => changeTargetingMode(-1);

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*gameModelInstance*/ 16) {
			 $$invalidate(5, selection = gameModelInstance.tower_defense.selection);
		}

		if ($$self.$$.dirty & /*selection, gameModelInstance*/ 48) {
			 if (selection) {
				$$invalidate(0, tower_info = gameModelInstance.tower_defense.getTower(selection.id) || undefined);
			} else {
				$$invalidate(0, tower_info = undefined);
			}
		}

		if ($$self.$$.dirty & /*selection, gameModelInstance*/ 48) {
			 if (selection) {
				$$invalidate(1, tower_stats = gameModelInstance.tower_defense.getTowerStats(selection.id));
			} else {
				$$invalidate(1, tower_stats = undefined);
			}
		}

		if ($$self.$$.dirty & /*tower_info*/ 1) {
			 if (tower_info) {
				$$invalidate(2, dps = tower_info.attributes.damage * (1000 / tower_info.attributes.attack_speed));
			}
		}
	};

	return [
		tower_info,
		tower_stats,
		dps,
		changeTargetingMode,
		gameModelInstance,
		selection,
		click_handler,
		click_handler_1
	];
}

class Tower_details extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default Tower_details;
//# sourceMappingURL=tower_details.svelte.js.map
