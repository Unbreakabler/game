import { SvelteComponent, init, safe_not_equal, empty, insert, group_outros, transition_out, check_outros, transition_in, detach, assign, exclude_internal_props, bubble, create_component, mount_component, destroy_component, create_slot, element, space, attr, append, action_destroyer, listen, update_slot, run_all, text, set_data } from '../../../../svelte/internal/index.mjs.js';
import Icon from '../Icon/Icon.svelte.js';
import r from '../Ripple/ripple.js';
import utils, { ClassBuilder } from '../../utils/classes.js';

/* node_modules/smelte/src/components/Tabs/TabButton.svelte generated by Svelte v3.32.1 */

function create_else_block(ctx) {
	let li;
	let div1;
	let t;
	let div0;
	let current;
	let mounted;
	let dispose;
	let if_block = /*icon*/ ctx[1] && create_if_block_2(ctx);
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);
	const default_slot_or_fallback = default_slot || fallback_block_1(ctx);

	return {
		c() {
			li = element("li");
			div1 = element("div");
			if (if_block) if_block.c();
			t = space();
			div0 = element("div");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			attr(div1, "class", /*tabClasses*/ ctx[5]);
			attr(li, "class", /*c*/ ctx[7]);
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, div1);
			if (if_block) if_block.m(div1, null);
			append(div1, t);
			append(div1, div0);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(div0, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(/*ripple*/ ctx[8].call(null, li)),
					listen(li, "click", /*click_handler_2*/ ctx[15]),
					listen(li, "click", /*click_handler_1*/ ctx[14])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*icon*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_2(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div1, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 65536) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, null, null);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*text*/ 8) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}

			if (!current || dirty & /*tabClasses*/ 32) {
				attr(div1, "class", /*tabClasses*/ ctx[5]);
			}

			if (!current || dirty & /*c*/ 128) {
				attr(li, "class", /*c*/ ctx[7]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(li);
			if (if_block) if_block.d();
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (40:0) {#if to}
function create_if_block(ctx) {
	let a;
	let div1;
	let t;
	let div0;
	let current;
	let mounted;
	let dispose;
	let if_block = /*icon*/ ctx[1] && create_if_block_1(ctx);
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);
	const default_slot_or_fallback = default_slot || fallback_block(ctx);

	return {
		c() {
			a = element("a");
			div1 = element("div");
			if (if_block) if_block.c();
			t = space();
			div0 = element("div");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			attr(div1, "class", /*tabClasses*/ ctx[5]);
			attr(a, "href", /*to*/ ctx[4]);
			attr(a, "class", /*c*/ ctx[7]);
		},
		m(target, anchor) {
			insert(target, a, anchor);
			append(a, div1);
			if (if_block) if_block.m(div1, null);
			append(div1, t);
			append(div1, div0);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(div0, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(/*ripple*/ ctx[8].call(null, a)),
					listen(a, "click", /*click_handler*/ ctx[13])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*icon*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div1, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 65536) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, null, null);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*text*/ 8) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}

			if (!current || dirty & /*tabClasses*/ 32) {
				attr(div1, "class", /*tabClasses*/ ctx[5]);
			}

			if (!current || dirty & /*to*/ 16) {
				attr(a, "href", /*to*/ ctx[4]);
			}

			if (!current || dirty & /*c*/ 128) {
				attr(a, "class", /*c*/ ctx[7]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(a);
			if (if_block) if_block.d();
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (65:6) {#if icon}
function create_if_block_2(ctx) {
	let icon_1;
	let current;

	icon_1 = new Icon({
			props: {
				class: "mb-1",
				color: /*textColor*/ ctx[6],
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(icon_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(icon_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const icon_1_changes = {};
			if (dirty & /*textColor*/ 64) icon_1_changes.color = /*textColor*/ ctx[6];

			if (dirty & /*$$scope, icon*/ 65538) {
				icon_1_changes.$$scope = { dirty, ctx };
			}

			icon_1.$set(icon_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(icon_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(icon_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(icon_1, detaching);
		}
	};
}

// (66:8) <Icon class="mb-1" color={textColor}>
function create_default_slot_1(ctx) {
	let t;

	return {
		c() {
			t = text(/*icon*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 2) set_data(t, /*icon*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (70:14) {text}
function fallback_block_1(ctx) {
	let t;

	return {
		c() {
			t = text(/*text*/ ctx[3]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*text*/ 8) set_data(t, /*text*/ ctx[3]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (48:6) {#if icon}
function create_if_block_1(ctx) {
	let icon_1;
	let current;

	icon_1 = new Icon({
			props: {
				class: "mb-1",
				color: /*textColor*/ ctx[6],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(icon_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(icon_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const icon_1_changes = {};
			if (dirty & /*textColor*/ 64) icon_1_changes.color = /*textColor*/ ctx[6];

			if (dirty & /*$$scope, icon*/ 65538) {
				icon_1_changes.$$scope = { dirty, ctx };
			}

			icon_1.$set(icon_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(icon_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(icon_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(icon_1, detaching);
		}
	};
}

// (49:8) <Icon class="mb-1" color={textColor}>
function create_default_slot(ctx) {
	let t;

	return {
		c() {
			t = text(/*icon*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 2) set_data(t, /*icon*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (53:14) {text}
function fallback_block(ctx) {
	let t;

	return {
		c() {
			t = text(/*text*/ ctx[3]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*text*/ 8) set_data(t, /*text*/ ctx[3]);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*to*/ ctx[4]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

const classesDefault = "duration-100 relative overflow-hidden text-center w-full h-full p-4 cursor-pointer flex mx-auto items-center text-sm h-full";

function instance($$self, $$props, $$invalidate) {
	let textColor;
	let c;
	let { $$slots: slots = {}, $$scope } = $$props;
	let { classes = classesDefault } = $$props;
	let { icon = "" } = $$props;
	let { id = "" } = $$props;
	let { text = "" } = $$props;
	let { to = "" } = $$props;
	let { selected = "" } = $$props;
	let { color = "primary" } = $$props;
	let { notSelectedColor = "white" } = $$props;
	let { tabClasses = "flex flex-col items-center content-center mx-auto" } = $$props;
	const ripple = r(color);
	const { txt, bg } = utils(color);
	const notSelected = utils(notSelectedColor);
	const cb = new ClassBuilder(classes, classesDefault);

	function click_handler(event) {
		bubble($$self, event);
	}

	function click_handler_1(event) {
		bubble($$self, event);
	}

	const click_handler_2 = () => $$invalidate(0, selected = id);

	$$self.$$set = $$new_props => {
		$$invalidate(21, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("classes" in $$new_props) $$invalidate(9, classes = $$new_props.classes);
		if ("icon" in $$new_props) $$invalidate(1, icon = $$new_props.icon);
		if ("id" in $$new_props) $$invalidate(2, id = $$new_props.id);
		if ("text" in $$new_props) $$invalidate(3, text = $$new_props.text);
		if ("to" in $$new_props) $$invalidate(4, to = $$new_props.to);
		if ("selected" in $$new_props) $$invalidate(0, selected = $$new_props.selected);
		if ("color" in $$new_props) $$invalidate(10, color = $$new_props.color);
		if ("notSelectedColor" in $$new_props) $$invalidate(11, notSelectedColor = $$new_props.notSelectedColor);
		if ("tabClasses" in $$new_props) $$invalidate(5, tabClasses = $$new_props.tabClasses);
		if ("$$scope" in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*selected, id*/ 5) {
			 $$invalidate(6, textColor = selected === id ? txt() : notSelected.txt());
		}

		 $$invalidate(7, c = cb.flush().add($$props.class).add("uppercase", icon).add(textColor).add(`hover:bg-${color}-transLight hover:${txt(900)}`).get());
	};

	$$props = exclude_internal_props($$props);

	return [
		selected,
		icon,
		id,
		text,
		to,
		tabClasses,
		textColor,
		c,
		ripple,
		classes,
		color,
		notSelectedColor,
		slots,
		click_handler,
		click_handler_1,
		click_handler_2,
		$$scope
	];
}

class TabButton extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			classes: 9,
			icon: 1,
			id: 2,
			text: 3,
			to: 4,
			selected: 0,
			color: 10,
			notSelectedColor: 11,
			tabClasses: 5
		});
	}
}

export default TabButton;
//# sourceMappingURL=TabButton.svelte.js.map
